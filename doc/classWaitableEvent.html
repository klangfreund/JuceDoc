<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>JUCE: WaitableEvent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classWaitableEvent-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WaitableEvent Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Allows threads to wait for events triggered by other threads.  
 <a href="classWaitableEvent.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3622062e48a177ec721120443ea17d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWaitableEvent.html#aa3622062e48a177ec721120443ea17d2">WaitableEvent</a> (bool manualReset=false) noexcept</td></tr>
<tr class="memdesc:aa3622062e48a177ec721120443ea17d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> object.  <a href="#aa3622062e48a177ec721120443ea17d2">More...</a><br /></td></tr>
<tr class="separator:aa3622062e48a177ec721120443ea17d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071eb054ec0ce9b69eb98bd9508c2cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWaitableEvent.html#af071eb054ec0ce9b69eb98bd9508c2cf">~WaitableEvent</a> () noexcept</td></tr>
<tr class="memdesc:af071eb054ec0ce9b69eb98bd9508c2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af071eb054ec0ce9b69eb98bd9508c2cf">More...</a><br /></td></tr>
<tr class="separator:af071eb054ec0ce9b69eb98bd9508c2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07d11a971a6c4d0d4e3a281cfa2af85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWaitableEvent.html#aa07d11a971a6c4d0d4e3a281cfa2af85">wait</a> (int timeOutMilliseconds=-1) const  noexcept</td></tr>
<tr class="memdesc:aa07d11a971a6c4d0d4e3a281cfa2af85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the calling thread until the event has been signalled.  <a href="#aa07d11a971a6c4d0d4e3a281cfa2af85">More...</a><br /></td></tr>
<tr class="separator:aa07d11a971a6c4d0d4e3a281cfa2af85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac709d0b5d533a55e24f7d0917eb53c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWaitableEvent.html#ac709d0b5d533a55e24f7d0917eb53c27">signal</a> () const  noexcept</td></tr>
<tr class="memdesc:ac709d0b5d533a55e24f7d0917eb53c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up any threads that are currently waiting on this object.  <a href="#ac709d0b5d533a55e24f7d0917eb53c27">More...</a><br /></td></tr>
<tr class="separator:ac709d0b5d533a55e24f7d0917eb53c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e760ddd9f18532dcacdab17bad78ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWaitableEvent.html#ab4e760ddd9f18532dcacdab17bad78ca">reset</a> () const  noexcept</td></tr>
<tr class="memdesc:ab4e760ddd9f18532dcacdab17bad78ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the event to an unsignalled state.  <a href="#ab4e760ddd9f18532dcacdab17bad78ca">More...</a><br /></td></tr>
<tr class="separator:ab4e760ddd9f18532dcacdab17bad78ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Allows threads to wait for events triggered by other threads. </p>
<p>A thread can call <a class="el" href="classWaitableEvent.html#aa07d11a971a6c4d0d4e3a281cfa2af85" title="Suspends the calling thread until the event has been signalled. ">wait()</a> on a WaitableObject, and this will suspend the calling thread until another thread wakes it up by calling the <a class="el" href="classWaitableEvent.html#ac709d0b5d533a55e24f7d0917eb53c27" title="Wakes up any threads that are currently waiting on this object. ">signal()</a> method. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa3622062e48a177ec721120443ea17d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WaitableEvent::WaitableEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>manualReset</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> object. </p>
<p>The object is initially in an unsignalled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manualReset</td><td>If this is false, the event will be reset automatically when the <a class="el" href="classWaitableEvent.html#aa07d11a971a6c4d0d4e3a281cfa2af85" title="Suspends the calling thread until the event has been signalled. ">wait()</a> method is called. If manualReset is true, then once the event is signalled, the only way to reset it will be by calling the <a class="el" href="classWaitableEvent.html#ab4e760ddd9f18532dcacdab17bad78ca" title="Resets the event to an unsignalled state. ">reset()</a> method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af071eb054ec0ce9b69eb98bd9508c2cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WaitableEvent::~WaitableEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If other threads are waiting on this object when it gets deleted, this can cause nasty errors, so be careful! </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa07d11a971a6c4d0d4e3a281cfa2af85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WaitableEvent::wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the calling thread until the event has been signalled. </p>
<p>This will wait until the object's <a class="el" href="classWaitableEvent.html#ac709d0b5d533a55e24f7d0917eb53c27" title="Wakes up any threads that are currently waiting on this object. ">signal()</a> method is called by another thread, or until the timeout expires.</p>
<p>After the event has been signalled, this method will return true and if manualReset was set to false in the <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a>'s constructor, then the event will be reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMilliseconds</td><td>the maximum time to wait, in milliseconds. A negative value will cause it to wait forever.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object has been signalled, false if the timeout expires first. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWaitableEvent.html#ac709d0b5d533a55e24f7d0917eb53c27" title="Wakes up any threads that are currently waiting on this object. ">signal</a>, <a class="el" href="classWaitableEvent.html#ab4e760ddd9f18532dcacdab17bad78ca" title="Resets the event to an unsignalled state. ">reset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac709d0b5d533a55e24f7d0917eb53c27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaitableEvent::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wakes up any threads that are currently waiting on this object. </p>
<p>If <a class="el" href="classWaitableEvent.html#ac709d0b5d533a55e24f7d0917eb53c27" title="Wakes up any threads that are currently waiting on this object. ">signal()</a> is called when nothing is waiting, the next thread to call <a class="el" href="classWaitableEvent.html#aa07d11a971a6c4d0d4e3a281cfa2af85" title="Suspends the calling thread until the event has been signalled. ">wait()</a> will return immediately and reset the signal.</p>
<p>If the <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> is manual reset, all current and future threads that wait upon this object will be woken, until <a class="el" href="classWaitableEvent.html#ab4e760ddd9f18532dcacdab17bad78ca" title="Resets the event to an unsignalled state. ">reset()</a> is explicitly called.</p>
<p>If the <a class="el" href="classWaitableEvent.html" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> is automatic reset, and one or more threads is waiting upon the object, then one of them will be woken up. If no threads are currently waiting, then the next thread to call <a class="el" href="classWaitableEvent.html#aa07d11a971a6c4d0d4e3a281cfa2af85" title="Suspends the calling thread until the event has been signalled. ">wait()</a> will be woken up. As soon as a thread is woken, the signal is automatically reset.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWaitableEvent.html#aa07d11a971a6c4d0d4e3a281cfa2af85" title="Suspends the calling thread until the event has been signalled. ">wait</a>, <a class="el" href="classWaitableEvent.html#ab4e760ddd9f18532dcacdab17bad78ca" title="Resets the event to an unsignalled state. ">reset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4e760ddd9f18532dcacdab17bad78ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaitableEvent::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the event to an unsignalled state. </p>
<p>If it's not already signalled, this does nothing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="juce__WaitableEvent_8h.html">juce_WaitableEvent.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>
<address class="footer"><small>All content &copy ROLI Ltd.</small></address><br/>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-19759318-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
