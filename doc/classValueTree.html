<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JUCE: ValueTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classValueTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ValueTree Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group__juce__data__structures.html">juce_data_structures</a> &raquo; <a class="el" href="group__juce__data__structures-values.html">values</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A powerful tree structure that can be used to hold free-form data, and which can handle its own undo and redo behaviour.  
 <a href="classValueTree.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structValueTree_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structValueTree_1_1Iterator.html" title="Iterator for a ValueTree. ">Iterator</a> for a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="structValueTree_1_1Iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree_1_1Listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classValueTree_1_1Listener.html" title="Listener class for events that happen to a ValueTree. ">Listener</a> class for events that happen to a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="classValueTree_1_1Listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5671081941b3db9db42bf7fcbd2629c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad5671081941b3db9db42bf7fcbd2629c">ValueTree</a> () noexcept</td></tr>
<tr class="memdesc:ad5671081941b3db9db42bf7fcbd2629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty, invalid <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="#ad5671081941b3db9db42bf7fcbd2629c">More...</a><br /></td></tr>
<tr class="separator:ad5671081941b3db9db42bf7fcbd2629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f66bc6973b9a7561af455bd6fb331c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#af2f66bc6973b9a7561af455bd6fb331c">ValueTree</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type)</td></tr>
<tr class="memdesc:af2f66bc6973b9a7561af455bd6fb331c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> with the given type name.  <a href="#af2f66bc6973b9a7561af455bd6fb331c">More...</a><br /></td></tr>
<tr class="separator:af2f66bc6973b9a7561af455bd6fb331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b76cb6c19452d487fd0356377d5925"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a58b76cb6c19452d487fd0356377d5925">ValueTree</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type, std::initializer_list&lt; <a class="el" href="structNamedValueSet_1_1NamedValue.html">NamedValueSet::NamedValue</a> &gt; properties, std::initializer_list&lt; <a class="el" href="classValueTree.html">ValueTree</a> &gt; subTrees={})</td></tr>
<tr class="memdesc:a58b76cb6c19452d487fd0356377d5925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a value tree from nested lists of properties and ValueTrees.  <a href="#a58b76cb6c19452d487fd0356377d5925">More...</a><br /></td></tr>
<tr class="separator:a58b76cb6c19452d487fd0356377d5925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96c26d40b84ef461c1afb882453612c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac96c26d40b84ef461c1afb882453612c">ValueTree</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;) noexcept</td></tr>
<tr class="memdesc:ac96c26d40b84ef461c1afb882453612c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference to another <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="#ac96c26d40b84ef461c1afb882453612c">More...</a><br /></td></tr>
<tr class="separator:ac96c26d40b84ef461c1afb882453612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7492a326b17d3840f6632137295e6f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab7492a326b17d3840f6632137295e6f9">ValueTree</a> (<a class="el" href="classValueTree.html">ValueTree</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:ab7492a326b17d3840f6632137295e6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab7492a326b17d3840f6632137295e6f9">More...</a><br /></td></tr>
<tr class="separator:ab7492a326b17d3840f6632137295e6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac064e1f6095e5f21fc065d9f6b76a407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac064e1f6095e5f21fc065d9f6b76a407">operator=</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;)</td></tr>
<tr class="memdesc:ac064e1f6095e5f21fc065d9f6b76a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this object to be a reference to the given tree.  <a href="#ac064e1f6095e5f21fc065d9f6b76a407">More...</a><br /></td></tr>
<tr class="separator:ac064e1f6095e5f21fc065d9f6b76a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0b4721cb1ec7f79c59192df3b97bcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a4e0b4721cb1ec7f79c59192df3b97bcc">~ValueTree</a> ()</td></tr>
<tr class="memdesc:a4e0b4721cb1ec7f79c59192df3b97bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a4e0b4721cb1ec7f79c59192df3b97bcc">More...</a><br /></td></tr>
<tr class="separator:a4e0b4721cb1ec7f79c59192df3b97bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998b47680444a00866db876dada8f254"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a998b47680444a00866db876dada8f254">operator==</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:a998b47680444a00866db876dada8f254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if both this and the other tree refer to the same underlying structure.  <a href="#a998b47680444a00866db876dada8f254">More...</a><br /></td></tr>
<tr class="separator:a998b47680444a00866db876dada8f254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70dad6ed84e611492a1c682a83fcce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ae70dad6ed84e611492a1c682a83fcce5">operator!=</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;) const noexcept</td></tr>
<tr class="memdesc:ae70dad6ed84e611492a1c682a83fcce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this and the other tree refer to different underlying structures.  <a href="#ae70dad6ed84e611492a1c682a83fcce5">More...</a><br /></td></tr>
<tr class="separator:ae70dad6ed84e611492a1c682a83fcce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fd1de59147fcd2cbf94c521d7e8594"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac5fd1de59147fcd2cbf94c521d7e8594">isEquivalentTo</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;) const</td></tr>
<tr class="memdesc:ac5fd1de59147fcd2cbf94c521d7e8594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison between the properties and children of two trees.  <a href="#ac5fd1de59147fcd2cbf94c521d7e8594">More...</a><br /></td></tr>
<tr class="separator:ac5fd1de59147fcd2cbf94c521d7e8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1506afbe6b840e4ab43fabf275845a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a9c1506afbe6b840e4ab43fabf275845a">isValid</a> () const noexcept</td></tr>
<tr class="memdesc:a9c1506afbe6b840e4ab43fabf275845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this tree refers to some valid data.  <a href="#a9c1506afbe6b840e4ab43fabf275845a">More...</a><br /></td></tr>
<tr class="separator:a9c1506afbe6b840e4ab43fabf275845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bb4e88b31f73f802799d6ebb324878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aa0bb4e88b31f73f802799d6ebb324878">createCopy</a> () const</td></tr>
<tr class="memdesc:aa0bb4e88b31f73f802799d6ebb324878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of this tree and all its sub-trees.  <a href="#aa0bb4e88b31f73f802799d6ebb324878">More...</a><br /></td></tr>
<tr class="separator:aa0bb4e88b31f73f802799d6ebb324878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2596a93fa05a1a0c95cd6c275e77982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad2596a93fa05a1a0c95cd6c275e77982">copyPropertiesFrom</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;source, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:ad2596a93fa05a1a0c95cd6c275e77982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites all the properties in this tree with the properties of the source tree.  <a href="#ad2596a93fa05a1a0c95cd6c275e77982">More...</a><br /></td></tr>
<tr class="separator:ad2596a93fa05a1a0c95cd6c275e77982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87912c9c35741a91a91a3ab23d6c49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aa87912c9c35741a91a91a3ab23d6c49a">copyPropertiesAndChildrenFrom</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;source, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:aa87912c9c35741a91a91a3ab23d6c49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all children and properties of this object with copies of those from the source object.  <a href="#aa87912c9c35741a91a91a3ab23d6c49a">More...</a><br /></td></tr>
<tr class="separator:aa87912c9c35741a91a91a3ab23d6c49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba6256213ee02c418e9ef3d320f0ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIdentifier.html">Identifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aaba6256213ee02c418e9ef3d320f0ff1">getType</a> () const noexcept</td></tr>
<tr class="memdesc:aaba6256213ee02c418e9ef3d320f0ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of this tree.  <a href="#aaba6256213ee02c418e9ef3d320f0ff1">More...</a><br /></td></tr>
<tr class="separator:aaba6256213ee02c418e9ef3d320f0ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d41bc2066cae65b69aa614aa0f68ff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a5d41bc2066cae65b69aa614aa0f68ff1">hasType</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;typeName) const noexcept</td></tr>
<tr class="memdesc:a5d41bc2066cae65b69aa614aa0f68ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tree has this type.  <a href="#a5d41bc2066cae65b69aa614aa0f68ff1">More...</a><br /></td></tr>
<tr class="separator:a5d41bc2066cae65b69aa614aa0f68ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16875a1c5f41f03f609a9d7870171fd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6">getProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const noexcept</td></tr>
<tr class="memdesc:a16875a1c5f41f03f609a9d7870171fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a named property.  <a href="#a16875a1c5f41f03f609a9d7870171fd6">More...</a><br /></td></tr>
<tr class="separator:a16875a1c5f41f03f609a9d7870171fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7c731c09608f59e9372b9221e35a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvar.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#adc7c731c09608f59e9372b9221e35a17">getProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, const <a class="el" href="classvar.html">var</a> &amp;defaultReturnValue) const</td></tr>
<tr class="memdesc:adc7c731c09608f59e9372b9221e35a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a named property, or the value of defaultReturnValue if the property doesn't exist.  <a href="#adc7c731c09608f59e9372b9221e35a17">More...</a><br /></td></tr>
<tr class="separator:adc7c731c09608f59e9372b9221e35a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22d040f68cf2f91784e18573cc6949a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvar.html">var</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad22d040f68cf2f91784e18573cc6949a">getPropertyPointer</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const noexcept</td></tr>
<tr class="memdesc:ad22d040f68cf2f91784e18573cc6949a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the value of a named property, or nullptr if the property doesn't exist.  <a href="#ad22d040f68cf2f91784e18573cc6949a">More...</a><br /></td></tr>
<tr class="separator:ad22d040f68cf2f91784e18573cc6949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c5127906a252590c8a64c48c5e99d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a55c5127906a252590c8a64c48c5e99d3">operator[]</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const noexcept</td></tr>
<tr class="memdesc:a55c5127906a252590c8a64c48c5e99d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a named property.  <a href="#a55c5127906a252590c8a64c48c5e99d3">More...</a><br /></td></tr>
<tr class="separator:a55c5127906a252590c8a64c48c5e99d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad236114dc2a8c41c799f1fc51d1614bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd">setProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, const <a class="el" href="classvar.html">var</a> &amp;newValue, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:ad236114dc2a8c41c799f1fc51d1614bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a named property of the tree.  <a href="#ad236114dc2a8c41c799f1fc51d1614bd">More...</a><br /></td></tr>
<tr class="separator:ad236114dc2a8c41c799f1fc51d1614bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbec0d665fb9d57b9fd7b3189ec0ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a0dbec0d665fb9d57b9fd7b3189ec0ee0">hasProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const noexcept</td></tr>
<tr class="memdesc:a0dbec0d665fb9d57b9fd7b3189ec0ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tree contains a named property.  <a href="#a0dbec0d665fb9d57b9fd7b3189ec0ee0">More...</a><br /></td></tr>
<tr class="separator:a0dbec0d665fb9d57b9fd7b3189ec0ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a07b801bd317aa8bf1ee9da5644fc35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a2a07b801bd317aa8bf1ee9da5644fc35">removeProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a2a07b801bd317aa8bf1ee9da5644fc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property from the tree.  <a href="#a2a07b801bd317aa8bf1ee9da5644fc35">More...</a><br /></td></tr>
<tr class="separator:a2a07b801bd317aa8bf1ee9da5644fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f750331b6a680f48751302be9313467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a2f750331b6a680f48751302be9313467">removeAllProperties</a> (<a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a2f750331b6a680f48751302be9313467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all properties from the tree.  <a href="#a2f750331b6a680f48751302be9313467">More...</a><br /></td></tr>
<tr class="separator:a2f750331b6a680f48751302be9313467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018730ee95c743705aa9132a37829b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a018730ee95c743705aa9132a37829b32">getNumProperties</a> () const noexcept</td></tr>
<tr class="memdesc:a018730ee95c743705aa9132a37829b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of properties that the tree contains.  <a href="#a018730ee95c743705aa9132a37829b32">More...</a><br /></td></tr>
<tr class="separator:a018730ee95c743705aa9132a37829b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea2ce53b4759a37d58e3f99d9702e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIdentifier.html">Identifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a6ea2ce53b4759a37d58e3f99d9702e36">getPropertyName</a> (<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> index) const noexcept</td></tr>
<tr class="memdesc:a6ea2ce53b4759a37d58e3f99d9702e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identifier of the property with a given index.  <a href="#a6ea2ce53b4759a37d58e3f99d9702e36">More...</a><br /></td></tr>
<tr class="separator:a6ea2ce53b4759a37d58e3f99d9702e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab2c5a5adfc77bb0831bc5746e32c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValue.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a1ab2c5a5adfc77bb0831bc5746e32c51">getPropertyAsValue</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager, bool shouldUpdateSynchronously=false)</td></tr>
<tr class="memdesc:a1ab2c5a5adfc77bb0831bc5746e32c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classValue.html" title="Represents a shared variant value. ">Value</a> object that can be used to control and respond to one of the tree's properties.  <a href="#a1ab2c5a5adfc77bb0831bc5746e32c51">More...</a><br /></td></tr>
<tr class="separator:a1ab2c5a5adfc77bb0831bc5746e32c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c1b4a7e3b9518568d4f692358c25e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a72c1b4a7e3b9518568d4f692358c25e5">getNumChildren</a> () const noexcept</td></tr>
<tr class="memdesc:a72c1b4a7e3b9518568d4f692358c25e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of child trees inside this one.  <a href="#a72c1b4a7e3b9518568d4f692358c25e5">More...</a><br /></td></tr>
<tr class="separator:a72c1b4a7e3b9518568d4f692358c25e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89053219ec515f24997a115cfd74e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a3f89053219ec515f24997a115cfd74e5">getChild</a> (<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> index) const</td></tr>
<tr class="memdesc:a3f89053219ec515f24997a115cfd74e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of this tree's sub-trees.  <a href="#a3f89053219ec515f24997a115cfd74e5">More...</a><br /></td></tr>
<tr class="separator:a3f89053219ec515f24997a115cfd74e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4047208c32c4e024a1f2809d1c35be48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a4047208c32c4e024a1f2809d1c35be48">getChildWithName</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type) const</td></tr>
<tr class="memdesc:a4047208c32c4e024a1f2809d1c35be48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first sub-tree with the specified type name.  <a href="#a4047208c32c4e024a1f2809d1c35be48">More...</a><br /></td></tr>
<tr class="separator:a4047208c32c4e024a1f2809d1c35be48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb29876616f005939915de3e6968818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aafb29876616f005939915de3e6968818">getOrCreateChildWithName</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:aafb29876616f005939915de3e6968818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first sub-tree with the specified type name, creating and adding a child with this name if there wasn't already one there.  <a href="#aafb29876616f005939915de3e6968818">More...</a><br /></td></tr>
<tr class="separator:aafb29876616f005939915de3e6968818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ae8b3ef8149fe5b9cc8b37d4ebd7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aa17ae8b3ef8149fe5b9cc8b37d4ebd7d">getChildWithProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;propertyName, const <a class="el" href="classvar.html">var</a> &amp;propertyValue) const</td></tr>
<tr class="memdesc:aa17ae8b3ef8149fe5b9cc8b37d4ebd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for the first sub-tree that has the specified property value.  <a href="#aa17ae8b3ef8149fe5b9cc8b37d4ebd7d">More...</a><br /></td></tr>
<tr class="separator:aa17ae8b3ef8149fe5b9cc8b37d4ebd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d639299ef9dfedc651544e05f06693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a93d639299ef9dfedc651544e05f06693">addChild</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child, <a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> index, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a93d639299ef9dfedc651544e05f06693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to this tree.  <a href="#a93d639299ef9dfedc651544e05f06693">More...</a><br /></td></tr>
<tr class="separator:a93d639299ef9dfedc651544e05f06693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3528b88d2a0af85e0d33dcaa75bc3ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab3528b88d2a0af85e0d33dcaa75bc3ab">appendChild</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:ab3528b88d2a0af85e0d33dcaa75bc3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new child sub-tree to this tree.  <a href="#ab3528b88d2a0af85e0d33dcaa75bc3ab">More...</a><br /></td></tr>
<tr class="separator:ab3528b88d2a0af85e0d33dcaa75bc3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b15bdb0b4a04b81c04e7059bb926c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a52b15bdb0b4a04b81c04e7059bb926c4">removeChild</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a52b15bdb0b4a04b81c04e7059bb926c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified child from this tree's child-list.  <a href="#a52b15bdb0b4a04b81c04e7059bb926c4">More...</a><br /></td></tr>
<tr class="separator:a52b15bdb0b4a04b81c04e7059bb926c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bee3734652dec6bb1d5c351a1268fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a3bee3734652dec6bb1d5c351a1268fc0">removeChild</a> (<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> childIndex, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a3bee3734652dec6bb1d5c351a1268fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a sub-tree from this tree.  <a href="#a3bee3734652dec6bb1d5c351a1268fc0">More...</a><br /></td></tr>
<tr class="separator:a3bee3734652dec6bb1d5c351a1268fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f8a28e02a782b0c95f855d0c29f0d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a91f8a28e02a782b0c95f855d0c29f0d9">removeAllChildren</a> (<a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a91f8a28e02a782b0c95f855d0c29f0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all child-trees.  <a href="#a91f8a28e02a782b0c95f855d0c29f0d9">More...</a><br /></td></tr>
<tr class="separator:a91f8a28e02a782b0c95f855d0c29f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d20bf6964bfc8c4a975543bca8ce53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab7d20bf6964bfc8c4a975543bca8ce53">moveChild</a> (<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> currentIndex, <a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> newIndex, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:ab7d20bf6964bfc8c4a975543bca8ce53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves one of the sub-trees to a different index.  <a href="#ab7d20bf6964bfc8c4a975543bca8ce53">More...</a><br /></td></tr>
<tr class="separator:ab7d20bf6964bfc8c4a975543bca8ce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1973a657c1c2907c9996038e7e756fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad1973a657c1c2907c9996038e7e756fe">isAChildOf</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;possibleParent) const noexcept</td></tr>
<tr class="memdesc:ad1973a657c1c2907c9996038e7e756fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this tree is a sub-tree (at any depth) of the given parent.  <a href="#ad1973a657c1c2907c9996038e7e756fe">More...</a><br /></td></tr>
<tr class="separator:ad1973a657c1c2907c9996038e7e756fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3e5c14e02f7ee3a958006d5146b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aecc3e5c14e02f7ee3a958006d5146b78">indexOf</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child) const noexcept</td></tr>
<tr class="memdesc:aecc3e5c14e02f7ee3a958006d5146b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a child item in this parent.  <a href="#aecc3e5c14e02f7ee3a958006d5146b78">More...</a><br /></td></tr>
<tr class="separator:aecc3e5c14e02f7ee3a958006d5146b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22561c896d9bcdb763d27aacbb5815c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad22561c896d9bcdb763d27aacbb5815c">getParent</a> () const noexcept</td></tr>
<tr class="memdesc:ad22561c896d9bcdb763d27aacbb5815c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent tree that contains this one.  <a href="#ad22561c896d9bcdb763d27aacbb5815c">More...</a><br /></td></tr>
<tr class="separator:ad22561c896d9bcdb763d27aacbb5815c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a16465630ab6a1c6a7bcb65ee77a3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a4a16465630ab6a1c6a7bcb65ee77a3df">getRoot</a> () const noexcept</td></tr>
<tr class="memdesc:a4a16465630ab6a1c6a7bcb65ee77a3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively finds the highest-level parent tree that contains this one.  <a href="#a4a16465630ab6a1c6a7bcb65ee77a3df">More...</a><br /></td></tr>
<tr class="separator:a4a16465630ab6a1c6a7bcb65ee77a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83099cde9f794842a2378c2935976a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a83099cde9f794842a2378c2935976a90">getSibling</a> (<a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> delta) const noexcept</td></tr>
<tr class="memdesc:a83099cde9f794842a2378c2935976a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of this tree's siblings in its parent's child list.  <a href="#a83099cde9f794842a2378c2935976a90">More...</a><br /></td></tr>
<tr class="separator:a83099cde9f794842a2378c2935976a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf33db0574a9f2673cde96bcfd808c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structValueTree_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a2cf33db0574a9f2673cde96bcfd808c5">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a2cf33db0574a9f2673cde96bcfd808c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a start iterator for the children in this tree.  <a href="#a2cf33db0574a9f2673cde96bcfd808c5">More...</a><br /></td></tr>
<tr class="separator:a2cf33db0574a9f2673cde96bcfd808c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40346edfb70253a482cd0642ac5ac577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structValueTree_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a40346edfb70253a482cd0642ac5ac577">end</a> () const noexcept</td></tr>
<tr class="memdesc:a40346edfb70253a482cd0642ac5ac577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an end iterator for the children in this tree.  <a href="#a40346edfb70253a482cd0642ac5ac577">More...</a><br /></td></tr>
<tr class="separator:a40346edfb70253a482cd0642ac5ac577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eaf13e771e7305a935ecdd8356f63e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXmlElement.html">XmlElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a54eaf13e771e7305a935ecdd8356f63e">createXml</a> () const</td></tr>
<tr class="memdesc:a54eaf13e771e7305a935ecdd8356f63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a> that holds a complete image of this tree and all its children.  <a href="#a54eaf13e771e7305a935ecdd8356f63e">More...</a><br /></td></tr>
<tr class="separator:a54eaf13e771e7305a935ecdd8356f63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243236064e188c79688c954b1c2e0998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classString.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a243236064e188c79688c954b1c2e0998">toXmlString</a> () const</td></tr>
<tr class="memdesc:a243236064e188c79688c954b1c2e0998"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a string containing an XML representation of the tree.  <a href="#a243236064e188c79688c954b1c2e0998">More...</a><br /></td></tr>
<tr class="separator:a243236064e188c79688c954b1c2e0998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6305ca13b5d95cd526e1ea7a953df365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365">writeToStream</a> (<a class="el" href="classOutputStream.html">OutputStream</a> &amp;output) const</td></tr>
<tr class="memdesc:a6305ca13b5d95cd526e1ea7a953df365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores this tree (and all its children) in a binary format.  <a href="#a6305ca13b5d95cd526e1ea7a953df365">More...</a><br /></td></tr>
<tr class="separator:a6305ca13b5d95cd526e1ea7a953df365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0d82471cb1119fc1a7b7018e3af394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394">addListener</a> (<a class="el" href="classValueTree_1_1Listener.html">Listener</a> *listener)</td></tr>
<tr class="memdesc:a0a0d82471cb1119fc1a7b7018e3af394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a listener to receive callbacks when this tree is changed in some way.  <a href="#a0a0d82471cb1119fc1a7b7018e3af394">More...</a><br /></td></tr>
<tr class="separator:a0a0d82471cb1119fc1a7b7018e3af394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8930aa94cb6e3714ef9e7449d08e5f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac8930aa94cb6e3714ef9e7449d08e5f6">removeListener</a> (<a class="el" href="classValueTree_1_1Listener.html">Listener</a> *listener)</td></tr>
<tr class="memdesc:ac8930aa94cb6e3714ef9e7449d08e5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a listener that was previously added with <a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394" title="Adds a listener to receive callbacks when this tree is changed in some way. ">addListener()</a>.  <a href="#ac8930aa94cb6e3714ef9e7449d08e5f6">More...</a><br /></td></tr>
<tr class="separator:ac8930aa94cb6e3714ef9e7449d08e5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b3ee8728b1c7e5e91b898c35f1b73e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a85b3ee8728b1c7e5e91b898c35f1b73e">setPropertyExcludingListener</a> (<a class="el" href="classValueTree_1_1Listener.html">Listener</a> *listenerToExclude, const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, const <a class="el" href="classvar.html">var</a> &amp;newValue, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr class="memdesc:a85b3ee8728b1c7e5e91b898c35f1b73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a named property of the tree, but will not notify a specified listener of the change.  <a href="#a85b3ee8728b1c7e5e91b898c35f1b73e">More...</a><br /></td></tr>
<tr class="separator:a85b3ee8728b1c7e5e91b898c35f1b73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164ff183e358b982b1a1f5dd1176ab88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a164ff183e358b982b1a1f5dd1176ab88">sendPropertyChangeMessage</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;property)</td></tr>
<tr class="memdesc:a164ff183e358b982b1a1f5dd1176ab88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a property-change callback to be triggered for the specified property, calling any listeners that are registered.  <a href="#a164ff183e358b982b1a1f5dd1176ab88">More...</a><br /></td></tr>
<tr class="separator:a164ff183e358b982b1a1f5dd1176ab88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdace65667e5bb2036310b4a91dd3a87"><td class="memTemplParams" colspan="2">template&lt;typename ElementComparator &gt; </td></tr>
<tr class="memitem:acdace65667e5bb2036310b4a91dd3a87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classValueTree.html#acdace65667e5bb2036310b4a91dd3a87">sort</a> (ElementComparator &amp;comparator, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager, bool retainOrderOfEquivalentItems)</td></tr>
<tr class="memdesc:acdace65667e5bb2036310b4a91dd3a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method uses a comparator object to sort the tree's children into order.  <a href="#acdace65667e5bb2036310b4a91dd3a87">More...</a><br /></td></tr>
<tr class="separator:acdace65667e5bb2036310b4a91dd3a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c3497b915a14168d347b20258122d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ade7c3497b915a14168d347b20258122d">getReferenceCount</a> () const noexcept</td></tr>
<tr class="memdesc:ade7c3497b915a14168d347b20258122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of references to the shared underlying data structure that this <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> is using.  <a href="#ade7c3497b915a14168d347b20258122d">More...</a><br /></td></tr>
<tr class="separator:ade7c3497b915a14168d347b20258122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0d2f1bdd6313e53f256ed015986f837a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a">fromXml</a> (const <a class="el" href="classXmlElement.html">XmlElement</a> &amp;xml)</td></tr>
<tr class="memdesc:a0d2f1bdd6313e53f256ed015986f837a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to recreate a tree from its XML representation.  <a href="#a0d2f1bdd6313e53f256ed015986f837a">More...</a><br /></td></tr>
<tr class="separator:a0d2f1bdd6313e53f256ed015986f837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41a9e45b2d15699b4e27bed3b31109c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad41a9e45b2d15699b4e27bed3b31109c">readFromStream</a> (<a class="el" href="classInputStream.html">InputStream</a> &amp;input)</td></tr>
<tr class="memdesc:ad41a9e45b2d15699b4e27bed3b31109c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads a tree from a stream that was written with <a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365" title="Stores this tree (and all its children) in a binary format. ">writeToStream()</a>.  <a href="#ad41a9e45b2d15699b4e27bed3b31109c">More...</a><br /></td></tr>
<tr class="separator:ad41a9e45b2d15699b4e27bed3b31109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9481d856db653baecf76032703858ca5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a9481d856db653baecf76032703858ca5">readFromData</a> (const void *data, size_t numBytes)</td></tr>
<tr class="memdesc:a9481d856db653baecf76032703858ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365" title="Stores this tree (and all its children) in a binary format. ">writeToStream()</a>.  <a href="#a9481d856db653baecf76032703858ca5">More...</a><br /></td></tr>
<tr class="separator:a9481d856db653baecf76032703858ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0858a2f15fef8b61adb6aa2aadc63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab5a0858a2f15fef8b61adb6aa2aadc63">readFromGZIPData</a> (const void *data, size_t numBytes)</td></tr>
<tr class="memdesc:ab5a0858a2f15fef8b61adb6aa2aadc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365" title="Stores this tree (and all its children) in a binary format. ">writeToStream()</a> and then zipped using <a class="el" href="classGZIPCompressorOutputStream.html" title="A stream which uses zlib to compress the data written into it. ">GZIPCompressorOutputStream</a>.  <a href="#ab5a0858a2f15fef8b61adb6aa2aadc63">More...</a><br /></td></tr>
<tr class="separator:ab5a0858a2f15fef8b61adb6aa2aadc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A powerful tree structure that can be used to hold free-form data, and which can handle its own undo and redo behaviour. </p>
<p>A <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> contains a list of named properties as var objects, and also holds any number of sub-trees.</p>
<p>Create <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> objects on the stack, and don't be afraid to copy them around, as they're simply a lightweight reference to a shared data container. Creating a copy of another <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> simply creates a new reference to the same underlying object - to make a separate, deep copy of a tree you should explicitly call <a class="el" href="classValueTree.html#aa0bb4e88b31f73f802799d6ebb324878" title="Returns a deep copy of this tree and all its sub-trees. ">createCopy()</a>.</p>
<p>Each <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> has a type name, in much the same way as an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a> has a tag name, and much of the structure of a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> is similar to an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a> tree. You can convert a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> to and from an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a>, and as long as the XML doesn't contain text elements, the conversion works well and makes a good serialisation format. They can also be serialised to a binary format, which is very fast and compact.</p>
<p>All the methods that change data take an optional <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands. ">UndoManager</a>, which will be used to track any changes to the object. For this to work, you have to be careful to consistently always use the same <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands. ">UndoManager</a> for all operations to any sub-tree inside the tree.</p>
<p>A <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> can only be a child of one parent at a time, so if you're moving one from one tree to another, be careful to always remove it first, before adding it. This could also mess up your undo/redo chain, so be wary! In a debug build you should hit assertions if you try to do anything dangerous, but there are still plenty of ways it could go wrong.</p>
<p>Note that although the children in a tree have a fixed order, the properties are not guaranteed to be stored in any particular order, so don't expect that a property's index will correspond to the order in which the property was added, or that it will remain constant when other properties are added or removed.</p>
<p>Listeners can be added to a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> to be told when properies change and when sub-trees are added or removed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values. ">var</a>, <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a></dd></dl>
<p>{DataStructures} </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5671081941b3db9db42bf7fcbd2629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5671081941b3db9db42bf7fcbd2629c">&#9670;&nbsp;</a></span>ValueTree() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree::ValueTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty, invalid <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>. </p>
<p>A <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> that is created with this constructor can't actually be used for anything, it's just a default 'null' <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> that can be returned to indicate some sort of failure. To create a real one, use the constructor that takes a string. </p>

</div>
</div>
<a id="af2f66bc6973b9a7561af455bd6fb331c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f66bc6973b9a7561af455bd6fb331c">&#9670;&nbsp;</a></span>ValueTree() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree::ValueTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> with the given type name. </p>
<p>Like an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a>, each <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> has a type, which you can access with <a class="el" href="classValueTree.html#aaba6256213ee02c418e9ef3d320f0ff1" title="Returns the type of this tree. ">getType()</a> and <a class="el" href="classValueTree.html#a5d41bc2066cae65b69aa614aa0f68ff1" title="Returns true if the tree has this type. ">hasType()</a>. </p>

</div>
</div>
<a id="a58b76cb6c19452d487fd0356377d5925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b76cb6c19452d487fd0356377d5925">&#9670;&nbsp;</a></span>ValueTree() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree::ValueTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="structNamedValueSet_1_1NamedValue.html">NamedValueSet::NamedValue</a> &gt;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classValueTree.html">ValueTree</a> &gt;&#160;</td>
          <td class="paramname"><em>subTrees</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a value tree from nested lists of properties and ValueTrees. </p>
<p>This code,</p>
<div class="fragment"><div class="line"><a class="code" href="classValueTree.html">ValueTree</a> groups</div><div class="line">{ <span class="stringliteral">&quot;ParameterGroups&quot;</span>, {},</div><div class="line">  {</div><div class="line">    { <span class="stringliteral">&quot;Group&quot;</span>, {{ <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;Tone Controls&quot;</span> }},</div><div class="line">      {</div><div class="line">        { <span class="stringliteral">&quot;Parameter&quot;</span>, {{ <span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;distortion&quot;</span> }, { <span class="stringliteral">&quot;value&quot;</span>, 0.5 }}},</div><div class="line">        { <span class="stringliteral">&quot;Parameter&quot;</span>, {{ <span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;reverb&quot;</span> },     { <span class="stringliteral">&quot;value&quot;</span>, 0.5 }}}</div><div class="line">      }</div><div class="line">    },</div><div class="line">    { <span class="stringliteral">&quot;Group&quot;</span>, {{ <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;Other Controls&quot;</span> }},</div><div class="line">      {</div><div class="line">        { <span class="stringliteral">&quot;Parameter&quot;</span>, {{ <span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;drywet&quot;</span> }, { <span class="stringliteral">&quot;value&quot;</span>, 0.5 }}},</div><div class="line">        { <span class="stringliteral">&quot;Parameter&quot;</span>, {{ <span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;gain&quot;</span> },   { <span class="stringliteral">&quot;value&quot;</span>, 0.5 }}}</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>produces this tree:</p>
<pre class="fragment">&lt;ParameterGroups&gt;
  &lt;Group name="Tone Controls"&gt;
    &lt;Parameter id="distortion" value="0.5"/&gt;
    &lt;Parameter id="reverb" value="0.5"/&gt;
  &lt;/Group&gt;
  &lt;Group name="Other Controls"&gt;
    &lt;Parameter id="drywet" value="0.5"/&gt;
    &lt;Parameter id="gain" value="0.5"/&gt;
  &lt;/Group&gt;
&lt;/ParameterGroups&gt;
</pre> 
</div>
</div>
<a id="ac96c26d40b84ef461c1afb882453612c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96c26d40b84ef461c1afb882453612c">&#9670;&nbsp;</a></span>ValueTree() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree::ValueTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a reference to another <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>. </p>

</div>
</div>
<a id="ab7492a326b17d3840f6632137295e6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7492a326b17d3840f6632137295e6f9">&#9670;&nbsp;</a></span>ValueTree() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree::ValueTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueTree.html">ValueTree</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="a4e0b4721cb1ec7f79c59192df3b97bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0b4721cb1ec7f79c59192df3b97bcc">&#9670;&nbsp;</a></span>~ValueTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueTree::~ValueTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac064e1f6095e5f21fc065d9f6b76a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac064e1f6095e5f21fc065d9f6b76a407">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a>&amp; ValueTree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes this object to be a reference to the given tree. </p>
<p>Note that calling this just points this at the new object and invokes the <a class="el" href="classValueTree_1_1Listener.html#a0fe714c55225f9f814801f875e5d41ca" title="This method is called when a tree is made to point to a different internal shared object...">Listener::valueTreeRedirected</a> callback, but it's not an undoable operation. If you're trying to replace an entire tree in an undoable way, you probably want to use copyPropertiesAndChildren() instead. </p>

</div>
</div>
<a id="a998b47680444a00866db876dada8f254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998b47680444a00866db876dada8f254">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if both this and the other tree refer to the same underlying structure. </p>
<p>Note that this isn't a value comparison - two independently-created trees which contain identical data are NOT considered equal. </p>

</div>
</div>
<a id="ae70dad6ed84e611492a1c682a83fcce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70dad6ed84e611492a1c682a83fcce5">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this and the other tree refer to different underlying structures. </p>
<p>Note that this isn't a value comparison - two independently-created trees which contain identical data are not considered equal. </p>

</div>
</div>
<a id="ac5fd1de59147fcd2cbf94c521d7e8594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fd1de59147fcd2cbf94c521d7e8594">&#9670;&nbsp;</a></span>isEquivalentTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::isEquivalentTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a deep comparison between the properties and children of two trees. </p>
<p>If all the properties and children of the two trees are the same (recursively), this returns true. The normal <a class="el" href="classValueTree.html#a998b47680444a00866db876dada8f254" title="Returns true if both this and the other tree refer to the same underlying structure. ">operator==()</a> only checks whether two trees refer to the same shared data structure, so use this method if you need to do a proper value comparison. </p>

</div>
</div>
<a id="a9c1506afbe6b840e4ab43fabf275845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1506afbe6b840e4ab43fabf275845a">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this tree refers to some valid data. </p>
<p>An invalid tree is one that was created with the default constructor. </p>

</div>
</div>
<a id="aa0bb4e88b31f73f802799d6ebb324878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bb4e88b31f73f802799d6ebb324878">&#9670;&nbsp;</a></span>createCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::createCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deep copy of this tree and all its sub-trees. </p>

</div>
</div>
<a id="ad2596a93fa05a1a0c95cd6c275e77982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2596a93fa05a1a0c95cd6c275e77982">&#9670;&nbsp;</a></span>copyPropertiesFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::copyPropertiesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites all the properties in this tree with the properties of the source tree. </p>
<p>Any properties that already exist will be updated; and new ones will be added, and any that are not present in the source tree will be removed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#aa87912c9c35741a91a91a3ab23d6c49a" title="Replaces all children and properties of this object with copies of those from the source object...">copyPropertiesAndChildrenFrom</a> </dd></dl>

</div>
</div>
<a id="aa87912c9c35741a91a91a3ab23d6c49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87912c9c35741a91a91a3ab23d6c49a">&#9670;&nbsp;</a></span>copyPropertiesAndChildrenFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::copyPropertiesAndChildrenFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all children and properties of this object with copies of those from the source object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#ad2596a93fa05a1a0c95cd6c275e77982" title="Overwrites all the properties in this tree with the properties of the source tree. ">copyPropertiesFrom</a> </dd></dl>

</div>
</div>
<a id="aaba6256213ee02c418e9ef3d320f0ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba6256213ee02c418e9ef3d320f0ff1">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIdentifier.html">Identifier</a> ValueTree::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of this tree. </p>
<p>The type is specified when the <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> is created. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a5d41bc2066cae65b69aa614aa0f68ff1" title="Returns true if the tree has this type. ">hasType</a> </dd></dl>

</div>
</div>
<a id="a5d41bc2066cae65b69aa614aa0f68ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d41bc2066cae65b69aa614aa0f68ff1">&#9670;&nbsp;</a></span>hasType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::hasType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the tree has this type. </p>
<p>The comparison is case-sensitive. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#aaba6256213ee02c418e9ef3d320f0ff1" title="Returns the type of this tree. ">getType</a> </dd></dl>

</div>
</div>
<a id="a16875a1c5f41f03f609a9d7870171fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16875a1c5f41f03f609a9d7870171fd6">&#9670;&nbsp;</a></span>getProperty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvar.html">var</a>&amp; ValueTree::getProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of a named property. </p>
<p>If no such property has been set, this will return a void variant. You can also use operator[] to get a property. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values. ">var</a>, <a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd" title="Changes a named property of the tree. ">setProperty</a>, <a class="el" href="classValueTree.html#ad22d040f68cf2f91784e18573cc6949a" title="Returns a pointer to the value of a named property, or nullptr if the property doesn&#39;t exist...">getPropertyPointer</a>, <a class="el" href="classValueTree.html#a0dbec0d665fb9d57b9fd7b3189ec0ee0" title="Returns true if the tree contains a named property. ">hasProperty</a> </dd></dl>

</div>
</div>
<a id="adc7c731c09608f59e9372b9221e35a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7c731c09608f59e9372b9221e35a17">&#9670;&nbsp;</a></span>getProperty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvar.html">var</a> ValueTree::getProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultReturnValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a named property, or the value of defaultReturnValue if the property doesn't exist. </p>
<p>You can also use operator[] and getProperty to get a property. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values. ">var</a>, <a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6" title="Returns the value of a named property. ">getProperty</a>, <a class="el" href="classValueTree.html#ad22d040f68cf2f91784e18573cc6949a" title="Returns a pointer to the value of a named property, or nullptr if the property doesn&#39;t exist...">getPropertyPointer</a>, <a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd" title="Changes a named property of the tree. ">setProperty</a>, <a class="el" href="classValueTree.html#a0dbec0d665fb9d57b9fd7b3189ec0ee0" title="Returns true if the tree contains a named property. ">hasProperty</a> </dd></dl>

</div>
</div>
<a id="ad22d040f68cf2f91784e18573cc6949a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22d040f68cf2f91784e18573cc6949a">&#9670;&nbsp;</a></span>getPropertyPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvar.html">var</a>* ValueTree::getPropertyPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the value of a named property, or nullptr if the property doesn't exist. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values. ">var</a>, <a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6" title="Returns the value of a named property. ">getProperty</a>, <a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd" title="Changes a named property of the tree. ">setProperty</a>, <a class="el" href="classValueTree.html#a0dbec0d665fb9d57b9fd7b3189ec0ee0" title="Returns true if the tree contains a named property. ">hasProperty</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__juce__data__structures-values.html#gad1dd20dd34843f4bcfe8516e7a10e871">CachedValue&lt; Type &gt;::forceUpdateOfCachedValue()</a>.</p>

</div>
</div>
<a id="a55c5127906a252590c8a64c48c5e99d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c5127906a252590c8a64c48c5e99d3">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvar.html">var</a>&amp; ValueTree::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of a named property. </p>
<p>If no such property has been set, this will return a void variant. This is the same as calling <a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6" title="Returns the value of a named property. ">getProperty()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6" title="Returns the value of a named property. ">getProperty</a> </dd></dl>

</div>
</div>
<a id="ad236114dc2a8c41c799f1fc51d1614bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad236114dc2a8c41c799f1fc51d1614bd">&#9670;&nbsp;</a></span>setProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a>&amp; ValueTree::setProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a named property of the tree. </p>
<p>The name identifier must not be an empty string. If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values. ">var</a>, <a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6" title="Returns the value of a named property. ">getProperty</a>, <a class="el" href="classValueTree.html#a2a07b801bd317aa8bf1ee9da5644fc35" title="Removes a property from the tree. ">removeProperty</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the value tree, so that you can daisy-chain calls to this method. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__juce__data__structures-values.html#gaa30d36d0218f11c28398eb8c11de3768">CachedValue&lt; Type &gt;::setValue()</a>, and <a class="el" href="classValueWithDefault.html#af5c21e299ff1e353cf7306c42542164f">ValueWithDefault::setValue()</a>.</p>

</div>
</div>
<a id="a0dbec0d665fb9d57b9fd7b3189ec0ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbec0d665fb9d57b9fd7b3189ec0ee0">&#9670;&nbsp;</a></span>hasProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::hasProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the tree contains a named property. </p>

<p class="reference">Referenced by <a class="el" href="classValueWithDefault.html#ae0220e3c462cb9f780e33fee3865e0ab">ValueWithDefault::isUsingDefault()</a>, and <a class="el" href="group__juce__data__structures-values.html#ga032a2eedc5ef836847371cea3b5e8963">CachedValue&lt; Type &gt;::isUsingDefault()</a>.</p>

</div>
</div>
<a id="a2a07b801bd317aa8bf1ee9da5644fc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a07b801bd317aa8bf1ee9da5644fc35">&#9670;&nbsp;</a></span>removeProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::removeProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a property from the tree. </p>
<p>If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p>

<p class="reference">Referenced by <a class="el" href="classValueWithDefault.html#a5c0b7595452fbd2b7f480c44d38ece2b">ValueWithDefault::resetToDefault()</a>, and <a class="el" href="group__juce__data__structures-values.html#gabf520f7db956e46018d027296488f8fd">CachedValue&lt; Type &gt;::resetToDefault()</a>.</p>

</div>
</div>
<a id="a2f750331b6a680f48751302be9313467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f750331b6a680f48751302be9313467">&#9670;&nbsp;</a></span>removeAllProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::removeAllProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all properties from the tree. </p>
<p>If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p>

</div>
</div>
<a id="a018730ee95c743705aa9132a37829b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018730ee95c743705aa9132a37829b32">&#9670;&nbsp;</a></span>getNumProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> ValueTree::getNumProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of properties that the tree contains. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a16875a1c5f41f03f609a9d7870171fd6" title="Returns the value of a named property. ">getProperty</a>. </dd></dl>

</div>
</div>
<a id="a6ea2ce53b4759a37d58e3f99d9702e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea2ce53b4759a37d58e3f99d9702e36">&#9670;&nbsp;</a></span>getPropertyName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIdentifier.html">Identifier</a> ValueTree::getPropertyName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identifier of the property with a given index. </p>
<p>Note that properties are not guaranteed to be stored in any particular order, so don't expect that the index will correspond to the order in which the property was added, or that it will remain constant when other properties are added or removed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a018730ee95c743705aa9132a37829b32" title="Returns the total number of properties that the tree contains. ">getNumProperties</a> </dd></dl>

</div>
</div>
<a id="a1ab2c5a5adfc77bb0831bc5746e32c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab2c5a5adfc77bb0831bc5746e32c51">&#9670;&nbsp;</a></span>getPropertyAsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValue.html">Value</a> ValueTree::getPropertyAsValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldUpdateSynchronously</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classValue.html" title="Represents a shared variant value. ">Value</a> object that can be used to control and respond to one of the tree's properties. </p>
<p>The <a class="el" href="classValue.html" title="Represents a shared variant value. ">Value</a> object will maintain a reference to this tree, and will use the undo manager when it needs to change the value. Attaching a <a class="el" href="classValue_1_1Listener.html" title="Receives callbacks when a Value object changes. ">Value::Listener</a> to the value object will provide callbacks whenever the property changes. If shouldUpdateSynchronously is true the <a class="el" href="classValue_1_1Listener.html" title="Receives callbacks when a Value object changes. ">Value::Listener</a> will be updated synchronously. </p><dl class="section see"><dt>See also</dt><dd>ValueSource::sendChangeMessage (bool) </dd></dl>

<p class="reference">Referenced by <a class="el" href="classValueWithDefault.html#a7d609f6a0a6169d9c44352f758e47459">ValueWithDefault::getPropertyAsValue()</a>, and <a class="el" href="group__juce__data__structures-values.html#gafd02fa783537a57a8c4e89b5d6fc0151">CachedValue&lt; Type &gt;::getPropertyAsValue()</a>.</p>

</div>
</div>
<a id="a72c1b4a7e3b9518568d4f692358c25e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c1b4a7e3b9518568d4f692358c25e5">&#9670;&nbsp;</a></span>getNumChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> ValueTree::getNumChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of child trees inside this one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a3f89053219ec515f24997a115cfd74e5" title="Returns one of this tree&#39;s sub-trees. ">getChild</a> </dd></dl>

</div>
</div>
<a id="a3f89053219ec515f24997a115cfd74e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f89053219ec515f24997a115cfd74e5">&#9670;&nbsp;</a></span>getChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one of this tree's sub-trees. </p>
<p>If the index is out of range, it'll return an invalid tree. (You can use <a class="el" href="classValueTree.html#a9c1506afbe6b840e4ab43fabf275845a" title="Returns true if this tree refers to some valid data. ">isValid()</a> to check whether a tree is valid) </p>

</div>
</div>
<a id="a4047208c32c4e024a1f2809d1c35be48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4047208c32c4e024a1f2809d1c35be48">&#9670;&nbsp;</a></span>getChildWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getChildWithName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first sub-tree with the specified type name. </p>
<p>If no such child tree exists, it'll return an invalid tree. (You can use <a class="el" href="classValueTree.html#a9c1506afbe6b840e4ab43fabf275845a" title="Returns true if this tree refers to some valid data. ">isValid()</a> to check whether a tree is valid) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#aafb29876616f005939915de3e6968818" title="Returns the first sub-tree with the specified type name, creating and adding a child with this name i...">getOrCreateChildWithName</a> </dd></dl>

</div>
</div>
<a id="aafb29876616f005939915de3e6968818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb29876616f005939915de3e6968818">&#9670;&nbsp;</a></span>getOrCreateChildWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getOrCreateChildWithName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first sub-tree with the specified type name, creating and adding a child with this name if there wasn't already one there. </p>
<p>The only time this will return an invalid object is when the object that you're calling the method on is itself invalid. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a4047208c32c4e024a1f2809d1c35be48" title="Returns the first sub-tree with the specified type name. ">getChildWithName</a> </dd></dl>

</div>
</div>
<a id="aa17ae8b3ef8149fe5b9cc8b37d4ebd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17ae8b3ef8149fe5b9cc8b37d4ebd7d">&#9670;&nbsp;</a></span>getChildWithProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getChildWithProperty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>propertyValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for the first sub-tree that has the specified property value. </p>
<p>This will scan the child trees in order, until it finds one that has property that matches the specified value. If no such tree is found, it'll return an invalid object. (You can use <a class="el" href="classValueTree.html#a9c1506afbe6b840e4ab43fabf275845a" title="Returns true if this tree refers to some valid data. ">isValid()</a> to check whether a tree is valid) </p>

</div>
</div>
<a id="a93d639299ef9dfedc651544e05f06693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d639299ef9dfedc651544e05f06693">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::addChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a child to this tree. </p>
<p>Make sure that the child being added has first been removed from any former parent before calling this, or else you'll hit an assertion. If the index is &lt; 0 or greater than the current number of sub-trees, the new one will be added at the end of the list. If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#ab3528b88d2a0af85e0d33dcaa75bc3ab" title="Appends a new child sub-tree to this tree. ">appendChild</a>, <a class="el" href="classValueTree.html#a52b15bdb0b4a04b81c04e7059bb926c4" title="Removes the specified child from this tree&#39;s child-list. ">removeChild</a> </dd></dl>

</div>
</div>
<a id="ab3528b88d2a0af85e0d33dcaa75bc3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3528b88d2a0af85e0d33dcaa75bc3ab">&#9670;&nbsp;</a></span>appendChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::appendChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a new child sub-tree to this tree. </p>
<p>This is equivalent to calling <a class="el" href="classValueTree.html#a93d639299ef9dfedc651544e05f06693" title="Adds a child to this tree. ">addChild()</a> with an index of -1. See <a class="el" href="classValueTree.html#a93d639299ef9dfedc651544e05f06693" title="Adds a child to this tree. ">addChild()</a> for more details. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a93d639299ef9dfedc651544e05f06693" title="Adds a child to this tree. ">addChild</a>, <a class="el" href="classValueTree.html#a52b15bdb0b4a04b81c04e7059bb926c4" title="Removes the specified child from this tree&#39;s child-list. ">removeChild</a> </dd></dl>

</div>
</div>
<a id="a52b15bdb0b4a04b81c04e7059bb926c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b15bdb0b4a04b81c04e7059bb926c4">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::removeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified child from this tree's child-list. </p>
<p>If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p>

</div>
</div>
<a id="a3bee3734652dec6bb1d5c351a1268fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bee3734652dec6bb1d5c351a1268fc0">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>childIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a sub-tree from this tree. </p>
<p>If the index is out-of-range, nothing will be changed. If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p>

</div>
</div>
<a id="a91f8a28e02a782b0c95f855d0c29f0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f8a28e02a782b0c95f855d0c29f0d9">&#9670;&nbsp;</a></span>removeAllChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::removeAllChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all child-trees. </p>
<p>If the undoManager parameter is not nullptr, its <a class="el" href="classUndoManager.html#a5f8b51dbb061ca3a1a8916938e0e2f49" title="Performs an action and adds it to the undo history list. ">UndoManager::perform()</a> method will be used, so that this change can be undone. Be very careful not to mix undoable and non-undoable changes! </p>

</div>
</div>
<a id="ab7d20bf6964bfc8c4a975543bca8ce53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d20bf6964bfc8c4a975543bca8ce53">&#9670;&nbsp;</a></span>moveChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::moveChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>currentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>newIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves one of the sub-trees to a different index. </p>
<p>This will move the child to a specified index, shuffling along any intervening items as required. So for example, if you have a list of { 0, 1, 2, 3, 4, 5 }, then calling move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentIndex</td><td>the index of the item to be moved. If this isn't a valid index, then nothing will be done </td></tr>
    <tr><td class="paramname">newIndex</td><td>the index at which you'd like this item to end up. If this is less than zero, the value will be moved to the end of the list </td></tr>
    <tr><td class="paramname">undoManager</td><td>the optional <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands. ">UndoManager</a> to use to store this transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1973a657c1c2907c9996038e7e756fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1973a657c1c2907c9996038e7e756fe">&#9670;&nbsp;</a></span>isAChildOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::isAChildOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>possibleParent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this tree is a sub-tree (at any depth) of the given parent. </p>
<p>This searches recursively, so returns true if it's a sub-tree at any level below the parent. </p>

</div>
</div>
<a id="aecc3e5c14e02f7ee3a958006d5146b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc3e5c14e02f7ee3a958006d5146b78">&#9670;&nbsp;</a></span>indexOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> ValueTree::indexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a child item in this parent. </p>
<p>If the child isn't found, this returns -1. </p>

</div>
</div>
<a id="ad22561c896d9bcdb763d27aacbb5815c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22561c896d9bcdb763d27aacbb5815c">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent tree that contains this one. </p>
<p>If the tree has no parent, this will return an invalid object. (You can use <a class="el" href="classValueTree.html#a9c1506afbe6b840e4ab43fabf275845a" title="Returns true if this tree refers to some valid data. ">isValid()</a> to check whether a tree is valid) </p>

</div>
</div>
<a id="a4a16465630ab6a1c6a7bcb65ee77a3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a16465630ab6a1c6a7bcb65ee77a3df">&#9670;&nbsp;</a></span>getRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getRoot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively finds the highest-level parent tree that contains this one. </p>
<p>If the tree has no parent, this will return itself. </p>

</div>
</div>
<a id="a83099cde9f794842a2378c2935976a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83099cde9f794842a2378c2935976a90">&#9670;&nbsp;</a></span>getSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> ValueTree::getSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a>&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of this tree's siblings in its parent's child list. </p>
<p>The delta specifies how far to move through the list, so a value of 1 would return the tree that follows this one, -1 would return the tree before it, 0 will return this one, etc. If the requested position is beyond the start or end of the child list, this will return an invalid object. </p>

</div>
</div>
<a id="a2cf33db0574a9f2673cde96bcfd808c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf33db0574a9f2673cde96bcfd808c5">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structValueTree_1_1Iterator.html">Iterator</a> ValueTree::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a start iterator for the children in this tree. </p>

</div>
</div>
<a id="a40346edfb70253a482cd0642ac5ac577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40346edfb70253a482cd0642ac5ac577">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structValueTree_1_1Iterator.html">Iterator</a> ValueTree::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an end iterator for the children in this tree. </p>

</div>
</div>
<a id="a54eaf13e771e7305a935ecdd8356f63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eaf13e771e7305a935ecdd8356f63e">&#9670;&nbsp;</a></span>createXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXmlElement.html">XmlElement</a>* ValueTree::createXml </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document. ">XmlElement</a> that holds a complete image of this tree and all its children. </p>
<p>If this tree is invalid, this may return nullptr. Otherwise, the XML that is produced can be used to recreate a similar tree by calling <a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a" title="Tries to recreate a tree from its XML representation. ">ValueTree::fromXml()</a>. The caller must delete the object that is returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a" title="Tries to recreate a tree from its XML representation. ">fromXml</a>, <a class="el" href="classValueTree.html#a243236064e188c79688c954b1c2e0998" title="This returns a string containing an XML representation of the tree. ">toXmlString</a> </dd></dl>

</div>
</div>
<a id="a0d2f1bdd6313e53f256ed015986f837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f1bdd6313e53f256ed015986f837a">&#9670;&nbsp;</a></span>fromXml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> ValueTree::fromXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXmlElement.html">XmlElement</a> &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to recreate a tree from its XML representation. </p>
<p>This isn't designed to cope with random XML data - it should only be fed XML that was created by the <a class="el" href="classValueTree.html#a54eaf13e771e7305a935ecdd8356f63e" title="Creates an XmlElement that holds a complete image of this tree and all its children. ">createXml()</a> method. </p>

</div>
</div>
<a id="a243236064e188c79688c954b1c2e0998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243236064e188c79688c954b1c2e0998">&#9670;&nbsp;</a></span>toXmlString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classString.html">String</a> ValueTree::toXmlString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a string containing an XML representation of the tree. </p>
<p>This is quite handy for debugging purposes, as it provides a quick way to view a tree. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#a54eaf13e771e7305a935ecdd8356f63e" title="Creates an XmlElement that holds a complete image of this tree and all its children. ">createXml()</a> </dd></dl>

</div>
</div>
<a id="a6305ca13b5d95cd526e1ea7a953df365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6305ca13b5d95cd526e1ea7a953df365">&#9670;&nbsp;</a></span>writeToStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::writeToStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOutputStream.html">OutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores this tree (and all its children) in a binary format. </p>
<p>Once written, the data can be read back with <a class="el" href="classValueTree.html#ad41a9e45b2d15699b4e27bed3b31109c" title="Reloads a tree from a stream that was written with writeToStream(). ">readFromStream()</a>.</p>
<p>It's much faster to load/save your tree in binary form than as XML, but obviously isn't human-readable. </p>

</div>
</div>
<a id="ad41a9e45b2d15699b4e27bed3b31109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41a9e45b2d15699b4e27bed3b31109c">&#9670;&nbsp;</a></span>readFromStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> ValueTree::readFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classInputStream.html">InputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reloads a tree from a stream that was written with <a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365" title="Stores this tree (and all its children) in a binary format. ">writeToStream()</a>. </p>

</div>
</div>
<a id="a9481d856db653baecf76032703858ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9481d856db653baecf76032703858ca5">&#9670;&nbsp;</a></span>readFromData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> ValueTree::readFromData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365" title="Stores this tree (and all its children) in a binary format. ">writeToStream()</a>. </p>

</div>
</div>
<a id="ab5a0858a2f15fef8b61adb6aa2aadc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a0858a2f15fef8b61adb6aa2aadc63">&#9670;&nbsp;</a></span>readFromGZIPData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> ValueTree::readFromGZIPData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a6305ca13b5d95cd526e1ea7a953df365" title="Stores this tree (and all its children) in a binary format. ">writeToStream()</a> and then zipped using <a class="el" href="classGZIPCompressorOutputStream.html" title="A stream which uses zlib to compress the data written into it. ">GZIPCompressorOutputStream</a>. </p>

</div>
</div>
<a id="a0a0d82471cb1119fc1a7b7018e3af394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0d82471cb1119fc1a7b7018e3af394">&#9670;&nbsp;</a></span>addListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::addListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueTree_1_1Listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a listener to receive callbacks when this tree is changed in some way. </p>
<p>The listener is added to this specific <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> object, and not to the shared object that it refers to. When this object is deleted, all the listeners will be lost, even if other references to the same <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> still exist. And if you use the operator= to make this refer to a different <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>, any listeners will begin listening to changes to the new tree instead of the old one.</p>
<p>When you're adding a listener, make sure that you add it to a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> instance that will last for as long as you need the listener. In general, you'd never want to add a listener to a local stack-based <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>, and would usually add one to a member variable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#ac8930aa94cb6e3714ef9e7449d08e5f6" title="Removes a listener that was previously added with addListener(). ">removeListener</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__juce__data__structures-values.html#ga43508969aaa4149c7d5668ad254fd9c0">CachedValue&lt; Type &gt;::CachedValue()</a>, and <a class="el" href="group__juce__data__structures-values.html#gad1dd20dd34843f4bcfe8516e7a10e871">CachedValue&lt; Type &gt;::forceUpdateOfCachedValue()</a>.</p>

</div>
</div>
<a id="ac8930aa94cb6e3714ef9e7449d08e5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8930aa94cb6e3714ef9e7449d08e5f6">&#9670;&nbsp;</a></span>removeListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::removeListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueTree_1_1Listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a listener that was previously added with <a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394" title="Adds a listener to receive callbacks when this tree is changed in some way. ">addListener()</a>. </p>

<p class="reference">Referenced by <a class="el" href="group__juce__data__structures-values.html#gad1dd20dd34843f4bcfe8516e7a10e871">CachedValue&lt; Type &gt;::forceUpdateOfCachedValue()</a>.</p>

</div>
</div>
<a id="a85b3ee8728b1c7e5e91b898c35f1b73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b3ee8728b1c7e5e91b898c35f1b73e">&#9670;&nbsp;</a></span>setPropertyExcludingListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a>&amp; ValueTree::setPropertyExcludingListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueTree_1_1Listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listenerToExclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a named property of the tree, but will not notify a specified listener of the change. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd" title="Changes a named property of the tree. ">setProperty</a> </dd></dl>

</div>
</div>
<a id="a164ff183e358b982b1a1f5dd1176ab88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164ff183e358b982b1a1f5dd1176ab88">&#9670;&nbsp;</a></span>sendPropertyChangeMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::sendPropertyChangeMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes a property-change callback to be triggered for the specified property, calling any listeners that are registered. </p>

</div>
</div>
<a id="acdace65667e5bb2036310b4a91dd3a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdace65667e5bb2036310b4a91dd3a87">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ValueTree::sort </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retainOrderOfEquivalentItems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method uses a comparator object to sort the tree's children into order. </p>
<p>The object provided must have a method of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> compareElements (<span class="keyword">const</span> <a class="code" href="classValueTree.html">ValueTree</a>&amp; first, <span class="keyword">const</span> <a class="code" href="classValueTree.html">ValueTree</a>&amp; second);</div></div><!-- fragment --><p>..and this method must return:</p><ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>To improve performance, the compareElements() method can be declared as static or const.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use for comparing elements. </td></tr>
    <tr><td class="paramname">undoManager</td><td>optional <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands. ">UndoManager</a> for storing the changes </td></tr>
    <tr><td class="paramname">retainOrderOfEquivalentItems</td><td>if this is true, then items which the comparator says are equivalent will be kept in the order in which they currently appear in the array. This is slower to perform, but may be important in some cases. If it's false, a faster algorithm is used, but equivalent elements may be rearranged. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__juce__core-system.html#ga85cf949ce0439306e4606bb784def674">JUCE_DEPRECATED_STATIC</a>, <a class="el" href="group__juce__core-system.html#ga8d339dd1e85e6fbefaf7638692d085c2">JUCE_PUBLIC_IN_DLL_BUILD</a>, and <a class="el" href="classOwnedArray.html#a04a21a831320e2ce76bee8ad881e1d90">OwnedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::sort()</a>.</p>

</div>
</div>
<a id="ade7c3497b915a14168d347b20258122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7c3497b915a14168d347b20258122d">&#9670;&nbsp;</a></span>getReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__audio__plugin__client-Unity.html#ga966b05a42d98c7296097e073c627dcd0">int</a> ValueTree::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of references to the shared underlying data structure that this <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> is using. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="juce__ValueTree_8h.html">juce_ValueTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 29 2018 20:00:17 for JUCE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
